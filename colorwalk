#!/usr/bin/env python

#    This file is part of Color Walk.
#
#    Color Walk is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    Color Walk is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Color Walk.  If not, see <http://www.gnu.org/licenses/>.


import sys, os, subprocess, threading, tempfile, shutil, time, gc, ConfigParser

import glib, gobject, gtk


IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.gif', '.png', '.bmp']
DEFAULT_SIZE = 123
FIT_BY_WIDTH = 456

LICENSE = '''This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses/>.'''


def choose_file(path=None):
    '''Creates a gtk.FileChooser and returns the value when the dialog is 
    destroyed.'''
    
    dialog = gtk.FileChooserDialog(title='Open File', buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
            
    if path:
        dialog.set_current_folder(path)
            
    filter = gtk.FileFilter()
    filter.set_name('All supported files')
    filter.add_pattern('*.cbz')
    filter.add_pattern('*.cbr')
    filter.add_pattern('*.zip')
    filter.add_pattern('*.rar')
    dialog.add_filter(filter)
    filter = gtk.FileFilter()
    filter.set_name('All files')
    filter.add_pattern('*')
    dialog.add_filter(filter)
    
    if dialog.run() == gtk.RESPONSE_ACCEPT:
        file = dialog.get_filename()
    
    else:
        file = None
    
    dialog.destroy()
    
    return file 

def find_executable(name):
    '''Tries to find an executable that's being used by as a helper application.
    If the program is found anywhere in PATH it returns true; otherwise it
    returns false.'''
    
    paths = os.environ['PATH'].split(':')
    found = False
    
    for path in paths:
        full_path = os.path.join(path, name)
            
        if os.path.exists(full_path):
            found = True
    
    return found

def find_ui_definition():
    '''Tries to find the XML GtkBuilder file in all the usual places. The first
    place to be checked is the current working directory. If it's found we
    assume that we're debugging. If the file can't be found this function
    returns None.'''
    
    paths = os.environ['XDG_DATA_DIRS'].split(':')
    return_value = None
    
    # This is mostly so that debugging isn't a pain in the ass.
    local = os.path.join(os.getcwd(), 'colorwalk.ui')
    
    if os.path.exists(local):
        return_value = local
    
    if not return_value:
        for path in paths:
            full_path = os.path.join(path, 'colorwalk/colorwalk.ui')
            
            if os.path.exists(full_path):
                return_value = full_path
                break
    
    return return_value


def new_pixbuf(path, mode, width=-1, height=-1):
    '''Returns a gtk.gdk.Pixbuf object at the appropriate size.'''
    
    if mode == DEFAULT_SIZE:
        return gtk.gdk.pixbuf_new_from_file(path)
    elif mode == FIT_BY_WIDTH:
        temp = gtk.gdk.pixbuf_new_from_file(path)
        
        if temp.get_width() > width:
            del temp
            return gtk.gdk.pixbuf_new_from_file_at_size(path, width, -1)
        else:
            return temp
    
    # gtk.gdk.Pixbufs don't seem to be collected properly. I'm not sure if this
    # is the best spot to call the garbage collecter though.
    gc.collect()


def open_email(dialog, link, user_data):
    '''Attempts to open the default email program to send an email.'''
    
    subprocess.call(['xdg-open', 'mailto:%s' % link])


def open_url(dialog, link, user_data):
    '''Opens a url in the default web browser.'''
    
    subprocess.call(['xdg-open', link])


class AboutDialog(gtk.AboutDialog):
    
    def __init__(self):
        '''A custom about dialog window.'''
        
        # This is as good a spot as any to set these hooks.
        gtk.about_dialog_set_email_hook(open_email, None)
        gtk.about_dialog_set_url_hook(open_url, None)
        
        # We don't use gtk.LinkButton, but gtk.AboutDialog does. In gtk 2.16.0
        # without this, the about uri opens twice:
        gtk.link_button_set_uri_hook(lambda *args:None)

        gtk.AboutDialog.__init__(self)
        
        self.set_logo_icon_name('image')
        self.set_name('Color Walk')
        self.set_version('0.1.0')
        self.set_comments('A really simple comic book reading application')
        self.set_copyright('Copyright (c) 2009 David Keogh')
        self.set_authors(['David Keogh <davekeogh@shaw.ca>'])
        self.set_license(LICENSE)
        self.set_wrap_license(True)
        self.set_website('http://members.shaw.ca/davekeogh/')


class Preferences(ConfigParser.SafeConfigParser):
    
    config_file = os.path.expanduser('~/.config/colorwalk/config')
    
    def __init__(self):
        '''Represents a configuration file at ~/.config/colorwalk/config. 
        Creates one with the default values if it does not exist.'''
        
        ConfigParser.SafeConfigParser.__init__(self)
        
        if not os.path.exists(os.path.split(self.config_file)[0]):
            os.mkdir(os.path.split(self.config_file)[0])
        
        if os.path.exists(self.config_file):
            self.read(self.config_file)
        
        else:
            # Set some reasonable default values
            self.add_section('Window')
            self.set('Window', 'width', str(800))
            self.set('Window', 'height', str(800))
            self.set('Window', 'fullscreen', str(False))
            self.set('Window', 'show_toolbar', str(True))
            
            self.add_section('Image')
            self.set('Image', 'scale', str(456)) # FIT_BY_WIDTH
            
            self.add_section('Preferences')
            self.set('Preferences', 'editor', '')
    
    def save(self):
        with open(self.config_file, 'w') as f:
            self.write(f)


class Window(gtk.Window):
    
    widgets = None
    worker = None
    lock = threading.Lock()
    preferences = Preferences()
    
    current_pixbuf = None
    prev_pixbuf = None
    next_pixbuf = None
    
    open_file = None
    index = 0
    images = []
    temp_dir = None
    browse_dir = None
    
    scale = FIT_BY_WIDTH
    width = 800
    height = 800
    
    def __init__(self, ui, file=None):
        '''The Color Walk main window. Arguments: ui is the file path of a XML 
        user interface file, and the optional argument, file, is the path to a
        file to open.'''
        
        gtk.Window.__init__(self)
        
        # Load the widgets from the XML file:
        self.widgets = gtk.Builder()
        self.widgets.add_from_file(ui)
        
        # Window events:
        self.connect('delete-event', self.quit)
        self.connect('configure-event', self.window_resized)
        self.connect('key-press-event', self.key_pressed)
        
        # Tool button events:
        self.widgets.get_object('open_button').connect('clicked', self.open)
        self.widgets.get_object('close_button').connect('clicked', self.close)
        self.widgets.get_object('forward_button').connect('clicked', self.go_forward)
        self.widgets.get_object('fullscreen_button').connect('toggled', self.toggle_fullscreen)
        self.widgets.get_object('back_button').connect('clicked', self.go_back)
        self.widgets.get_object('normal_button').connect('toggled', self.toggle_scale)
        self.widgets.get_object('fit_button').connect('toggled', self.toggle_scale)
        self.widgets.get_object('about_button').connect('clicked', self.about)
        self.widgets.get_object('help_button').connect('clicked', self.help)
        self.widgets.get_object('prefs_button').connect('clicked', self.edit_preferences)
        
        # Context menu events:
        self.widgets.get_object('viewport').connect('button-press-event', self.image_clicked)
        self.widgets.get_object('context-menu-open').connect('activate', self.open)
        self.widgets.get_object('context-menu-close').connect('activate', self.close)
        self.widgets.get_object('context-menu-edit').connect('activate', self.edit_image)
        self.widgets.get_object('context-menu-save').connect('activate', self.save_image)
        self.widgets.get_object('context-menu-back').connect('activate', self.go_back)
        self.widgets.get_object('context-menu-forward').connect('activate', self.go_forward)
        self.widgets.get_object('context-menu-quit').connect('activate', self.quit)
        self.widgets.get_object('context-menu-preferences').connect('activate', self.edit_preferences)
        
        # Entry events:
        self.widgets.get_object('entry').connect('insert-text', self.entry_contents_changed)
        self.widgets.get_object('entry').connect('activate', self.entry_activated)
        
        # Setup the accelerators:
        accel_group = gtk.AccelGroup()
        self.add_accel_group(accel_group)
        
        # Key values = o, w, q:
        self.widgets.get_object('context-menu-open').add_accelerator('activate', accel_group, 111, gtk.gdk.CONTROL_MASK, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('context-menu-close').add_accelerator('activate', accel_group, 119, gtk.gdk.CONTROL_MASK, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('context-menu-quit').add_accelerator('activate', accel_group, 113, gtk.gdk.CONTROL_MASK, (gtk.ACCEL_LOCKED))
        
        # Key values = backspace, page up, back arrow:
        self.widgets.get_object('context-menu-back').add_accelerator('activate', accel_group, 65288, 0, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('context-menu-back').add_accelerator('activate', accel_group, 65365, 0, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('context-menu-back').add_accelerator('activate', accel_group, 65361, 0, (gtk.ACCEL_LOCKED))
        
        # Key values = spacebar, page down, forward arrow:
        self.widgets.get_object('context-menu-forward').add_accelerator('activate', accel_group, 32, 0, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('context-menu-forward').add_accelerator('activate', accel_group, 65366, 0, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('context-menu-forward').add_accelerator('activate', accel_group, 65363, 0, (gtk.ACCEL_LOCKED))
        
        # See the key_pressed method for more 'pseudo accelerators'
        
        # Resize window according to preferences:
        self.resize(self.preferences.getint('Window', 'width'),
                    self.preferences.getint('Window', 'height'))
        self.scale = self.preferences.getint('Image', 'scale')
        
        if self.preferences.getboolean('Window', 'fullscreen'):
            self.widgets.get_object('fullscreen_button').set_active(True)
        
        if not self.preferences.getboolean('Window', 'show_toolbar'):
            self.widgets.get_object('toolbar').hide()
        
        self.widgets.get_object('context-menu').attach_to_widget(self.widgets.get_object('viewport'), lambda *args:None)
        
        # Work around a bug in glade-3:
        self.widgets.get_object('image').clear()
        
        # Display the widgets:
        self.set_icon_name('image')
        self.set_title('Color Walk')
        self.add(self.widgets.get_object('vbox'))
        self.set_widget_sensitivity(False)
        self.show()
        
        # Open a file passed on the command line:
        if file:
            self.open(self.widgets.get_object('open_button'), file=file)
    
    def about(self, button):
        '''A callback connected to the about button's clicked signal. Shows the
        about dialog.'''
        
        dialog = AboutDialog()
        if dialog.run():
            dialog.destroy()
    
    def close(self, button):
        '''A callback connected to the close button's clicked signal. Closes the
        file and resets the title, image, and all the toolbar widgets.'''
        
        if self.open_file:
            self.close_file()
            self.set_title('Color Walk')
            self.widgets.get_object('entry').set_text('')
            self.widgets.get_object('label').set_text('')
            self.set_widget_sensitivity(False)
            self.widgets.get_object('image').clear()
    
    def close_file(self):
        '''Reset all relevant variables and delete the temporary directory.'''
        
        self.current_pixbuf = None
        self.next_pixbuf = None
        self.prev_pixbuf = None
        
        self.index = 0
        self.images = []
        self.open_file = None
        
        if self.temp_dir:
            shutil.rmtree(self.temp_dir)
            self.temp_dir = None
    
    def edit_image(self, widget):
        '''A callback connected to the edit context menu item's activate signal.
        It launches a helper application (like the gimp) to edit the image.'''
        
        self.show_status_message('Running <i>%s %s</i> ...' % (self.preferences.get('Preferences', 'editor'), os.path.join(self.temp_dir, self.images[self.index])))
        
        subprocess.Popen([self.preferences.get('Preferences', 'editor'), os.path.join(self.temp_dir, self.images[self.index])])
    
    def edit_preferences(self, widget):
        '''A callback connected to the preferences button's clicked signal.
        Displays a dialog containing the application's options.'''
        
        dialog = gtk.Dialog('Color Walk Preferences', self,
                            gtk.DIALOG_MODAL | gtk.DIALOG_NO_SEPARATOR, ())
        dialog.get_content_area().add((self.widgets.get_object('prefs-vbox')))
        button = dialog.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
        button.grab_default()
        button.grab_focus()
        dialog.set_icon_name('preferences-desktop')
        
        def update_icon():
            if not self.widgets.get_object('editor_entry').get_text():
                self.widgets.get_object('editor_image').set_from_stock(gtk.STOCK_NO, gtk.ICON_SIZE_BUTTON)
            else:
                if find_executable(self.widgets.get_object('editor_entry').get_text()):
                    self.widgets.get_object('editor_image').set_from_stock(gtk.STOCK_YES, gtk.ICON_SIZE_BUTTON)
                else:
                    self.widgets.get_object('editor_image').set_from_stock(gtk.STOCK_NO, gtk.ICON_SIZE_BUTTON)
        
        def editor_text_changed(entry):
            update_icon()
        
        self.widgets.get_object('editor_entry').connect('changed', editor_text_changed)
        
        if self.preferences.get('Preferences', 'editor'):
            self.widgets.get_object('editor_entry').set_text(self.preferences.get('Preferences', 'editor'))
            
            update_icon()
        
        self.widgets.get_object('toolbar_checkbutton').set_active(self.preferences.getboolean('Window', 'show_toolbar'))
        self.widgets.get_object('fullscreen_checkbutton').set_active(self.preferences.getboolean('Window', 'fullscreen'))
        
        if dialog.run():
            dialog.get_content_area().remove(self.widgets.get_object('prefs-vbox'))
            dialog.destroy()
            
            self.preferences.set('Preferences', 'editor', self.widgets.get_object('editor_entry').get_text())
            self.preferences.set('Window', 'show_toolbar', str(self.widgets.get_object('toolbar_checkbutton').get_active()))
            self.preferences.set('Window', 'fullscreen', str(self.widgets.get_object('fullscreen_checkbutton').get_active()))
            
            self.reload_preferences()
    
    def entry_activated(self, entry):
        '''A callback connected to the entry's activate signal. First the text
        is verified and then, if it's numerical, the correct page is opened.'''
        
        def fail():
            '''This is run when what's entered is invalid. It resets the entry
            widget and removes the focus from the entry.'''
            
            entry.set_text(str(self.index + 1))
            self.unfocus()
        
        try:
            index = int(entry.get_text()) - 1
            
            if index >= 0 and index < len(self.images):
                self.index = index
                
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.lock.acquire()
                    
                    self.reset_scrollbars()
                    self.set_widget_state()
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    try:
                        self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                    except IndexError:
                        self.next_pixbuf = None
                    
                    try:
                        self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                    except IndexError:
                        self.prev_pixbuf = None
                    
                    self.lock.release()
                
                self.worker = threading.Thread(target=worker)
                self.worker.start()
            else:
                # The number falls outside the actual number of images.
                fail()
        except ValueError:
            # Non-numerical value.
            fail()
    
    def entry_contents_changed(self, entry, text, text_length, pointer):
        '''A callback connected to the entry's contents-changed signal. Prevents
        any non numerical characters from being entered into the entry.'''
        
        try:
            int(text)
        except ValueError:
            entry.stop_emission('insert-text')
    
    def get_available_space(self):
        '''Returns the amount of space that the image can occupy in pixels.'''
        
        # TODO: Find a way to get the scrollbar's actual width.
        scrollbar = 20
        
        height = self.height - self.widgets.get_object('toolbar').size_request()[0]
        width = self.width - scrollbar
        
        return (width, height)
    
    def go_back(self, button):
        '''A callback connected to the back button's clicked signal. Displays
        the previous page.'''
        
        if self.index >= 0:
            if self.prev_pixbuf:
                self.index -= 1
                
                self.next_pixbuf = self.current_pixbuf
                self.current_pixbuf = self.prev_pixbuf
                self.prev_pixbuf = None
                
                self.reset_scrollbars()
                self.set_widget_state()
                
                self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.lock.acquire()
                    
                    if self.index > 0:
                        self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                    
                    self.lock.release()
                
                self.worker = threading.Thread(target=worker)
                self.worker.start()
    
    def go_forward(self, button):
        '''A callback connected to the forward button's clicked signal. Displays
        the next page.'''
        
        if self.index < len(self.images):
            if self.next_pixbuf:
                self.index += 1
                
                self.prev_pixbuf = self.current_pixbuf
                self.current_pixbuf = self.next_pixbuf
                self.next_pixbuf = None
                
                self.reset_scrollbars()
                self.set_widget_state()
                
                self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                
                if self.index != len(self.images) - 1:
                    def worker():
                        '''Runs in the background to avoid blocking the UI.
                        Opens the required images.'''
                        
                        self.lock.acquire()
                        
                        self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                        
                        self.lock.release()
                    
                    self.worker = threading.Thread(target=worker)
                    self.worker.start()
    
    def go_to_index(self, index):
        '''Displays the page refered to by the value of index. This is only used
        internally with safe values for index, so we don't need to check the
        value of index here.'''
        
        self.index = index
        
        def worker():
            '''Runs in the background to avoid blocking the UI. Opens the
            required images.'''
            
            self.lock.acquire()
            
            self.reset_scrollbars()
            self.set_widget_state()
            
            self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
            self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
            
            if self.index != len(self.images) - 1:
                self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
            
            if self.index > 0:
                self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
            
            self.lock.release()
        
        self.worker = threading.Thread(target=worker)
        self.worker.start()
    
    def help(self, widget):
        '''A callback connected to the help button's clicked signal. Displays a
        dialog listing all the keyboard shortcuts.'''
        
        dialog = gtk.Dialog('Color Walk Help', self,
                            gtk.DIALOG_MODAL | gtk.DIALOG_NO_SEPARATOR, ())
        dialog.get_content_area().add((self.widgets.get_object('dialog-vbox')))
        button = dialog.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
        button.grab_default()
        button.grab_focus()
        dialog.set_icon_name('help')
        dialog.resize(350, 200)
        
        if dialog.run():
            dialog.get_content_area().remove(self.widgets.get_object('dialog-vbox'))
            dialog.destroy()
    
    def image_clicked(self, viewport, event):
        '''A callback connected to the viewport's button-pressed-event. Displays
        a menu whent he right mouse button is pressed.'''
        
        if event.button == 3:
            if not self.preferences.get('Preferences', 'editor'):
                self.widgets.get_object('context-menu-edit').set_sensitive(False)
            else:
                if self.open_file:
                    self.widgets.get_object('context-menu-edit').set_sensitive(True)
            
            self.widgets.get_object('context-menu').popup(None, None, None, event.button, event.time, None)
    
    def key_pressed(self, widget, event):
        '''A callback connected to the window's key-pressed-event. Does 
        something depending on the key.'''
        
        if event.keyval == 65480: # F11
            self.widgets.get_object('fullscreen_button').set_active(not self.widgets.get_object('fullscreen_button').get_active())
        
        if event.keyval == 65470: # F1
            self.help(widget)
        
        if self.open_file:
            if event.keyval == 65360: # Home
                self.go_to_index(0)
            
            elif event.keyval == 65367: # End
                self.go_to_index(len(self.images) - 1)
    
    def open(self, button, file=None):
        '''A callback connected to the open button's clicked signal. Can also be
        called with a file as an argument to open files passed as command line
        arguments. If the file is valid the archive is opened. Otherwise, the 
        fail method is called and an error message is displayed.'''
        
        button.set_sensitive(False)
        
        if file:
            file = os.path.abspath(file)
            self.browse_dir = os.path.split(file)[0]
            
            if not os.path.exists(file):
                file = None
        
        else:
            file = choose_file(self.browse_dir)
        
            try:
                self.browse_dir = os.path.split(file)[0]
                
                if self.open_file:
                    self.close_file()
            
            except AttributeError:
                pass
        
        if file:
            ext = os.path.splitext(file)[1]
            
            if ext == '.zip' or ext == '.cbz':
                self.temp_dir = tempfile.mkdtemp(prefix='colorwalk-%s-' % os.environ['USER'])
                command = 'unzip -j \"%s\" -d \"%s\"' % (file, self.temp_dir)
                
            elif ext == '.rar' or ext == '.cbr':
                self.temp_dir = tempfile.mkdtemp(prefix='colorwalk-%s-' % os.environ['USER'])
                command = 'unrar e \"%s\" \"%s\"' % (file, self.temp_dir)
                
            else:
                command = None
        
        else:
            command = None
        
        if command:
            # It's less confusing if we get rid of any old image first:
            self.widgets.get_object('image').clear()
            
            def worker():
                '''Runs in the background to avoid blocking the UI. Opens the
                required images.'''
                
                self.lock.acquire()
                
                self.widgets.get_object('status_label').set_markup('Opening <i>%s</i> ...' % os.path.split(file)[1])
                self.widgets.get_object('status_box').show()
                
                p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                
                while p.poll() == None:
                    # Wait until the archive is done extracting before we do
                    # anything else.
                    self.widgets.get_object('progressbar').pulse()
                    time.sleep(0.1)
                
                for f in os.listdir(self.temp_dir):
                    # Only add files with a valid extension to the list of
                    # images.
                    if os.path.splitext(f)[1].lower() in IMAGE_EXTENSIONS:
                        self.images.append(f)
                    
                    self.widgets.get_object('progressbar').pulse()
                
                if not len(self.images):
                    button.set_sensitive(True)
                    self.show_status_message('<i>%s</i> cannot be opened because it does not contain any images.' % os.path.split(file)[1])
                
                else:
                    self.images.sort(key=str.lower)
                    self.open_file = file
                    
                    self.reset_scrollbars()
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[0]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    self.widgets.get_object('progressbar').pulse()
                    
                    button.set_sensitive(True)
                    self.set_widget_state()
                    self.set_widget_sensitivity(True)
                    self.widgets.get_object('status_box').hide()
                    
                    self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[1]), self.scale, *self.get_available_space())
                
                self.lock.release()
            
            self.worker = threading.Thread(target=worker)
            
            self.worker.start()
        
        elif file and not command:
            button.set_sensitive(True)
            self.show_status_message('<i>%s</i> cannot be opened because it is not a valid archive file.' % os.path.split(file)[1])
        
        else:
            button.set_sensitive(True)
    
    def quit(self, window, event=None):
        '''A callback connected to the window's delete-event signal. It deletes
        the temporary directory, if it exists, saves the preferences, and
        destroys the window.'''
        
        self.close_file()
        
        self.preferences.set('Window', 'width', str(self.width))
        self.preferences.set('Window', 'height', str(self.height))
        self.preferences.set('Image', 'scale', str(self.scale))
        self.preferences.save()
        
        gtk.main_quit()
        sys.exit(0)
    
    def reload_preferences(self):
        '''Applies the preference values to their related widgets. This is run 
        after the preferences dialog is closed.'''
        
        if self.preferences.getboolean('Window', 'show_toolbar'):
            self.widgets.get_object('toolbar').show()
        else:
            self.widgets.get_object('toolbar').hide()
    
    def reset_scrollbars(self):
        '''This method moves the scrollbars back to their default positions.'''
        
        # TODO: Add support for RTL
        
        viewport = self.widgets.get_object('scrolledwindow')
        hadj = viewport.get_hadjustment()
        vadj = viewport.get_vadjustment()
        vadj.set_value(vadj.lower)
        hadj.set_value(hadj.lower)
        viewport.set_hadjustment(hadj)
        viewport.set_vadjustment(vadj)
    
    def save_image(self, widget):
        '''A callback connected to the save context menu item's activate signal.
        This allows the user to save the currently displayed image somewhere.'''
        
        dialog = gtk.FileChooserDialog(title='Save File', action=gtk.FILE_CHOOSER_ACTION_SAVE, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, gtk.STOCK_SAVE, gtk.RESPONSE_ACCEPT))
        dialog.set_current_folder(self.browse_dir)
        dialog.set_current_name(self.images[self.index])
        dialog.set_do_overwrite_confirmation(True)
        
        if dialog.run() == gtk.RESPONSE_ACCEPT:
            file = dialog.get_filename()
            
            shutil.copyfile(os.path.join(self.temp_dir, self.images[self.index]), file)
        
        dialog.destroy()
    
    def set_widget_sensitivity(self, bool):
        '''Calls the toolbar buttons and menu items set_sensitive methods with
        the value of bool.'''
        
        self.widgets.get_object('close_button').set_sensitive(bool)
        self.widgets.get_object('back_button').set_sensitive(bool)
        self.widgets.get_object('forward_button').set_sensitive(bool)
        self.widgets.get_object('normal_button').set_sensitive(bool)
        self.widgets.get_object('fit_button').set_sensitive(bool)
        self.widgets.get_object('entry').set_sensitive(bool)
        self.widgets.get_object('label').set_sensitive(bool)
        
        # Context menu widgets:
        self.widgets.get_object('context-menu-close').set_sensitive(bool)
        self.widgets.get_object('context-menu-back').set_sensitive(bool)
        self.widgets.get_object('context-menu-forward').set_sensitive(bool)
        self.widgets.get_object('context-menu-edit').set_sensitive(bool)
        self.widgets.get_object('context-menu-save').set_sensitive(bool)
    
    def set_widget_state(self):
        '''Updates properites of any widget that may change depending on whether
        an image is being displayed.'''
        
        self.set_title('%s - %s' % (os.path.split(self.open_file)[1], self.images[self.index]))
        self.widgets.get_object('entry').set_text(str(self.index + 1))
        self.widgets.get_object('label').set_text('of %d' % len(self.images))
        
        self.unfocus()
        
        if self.index == 0:
            self.widgets.get_object('back_button').set_sensitive(False)
        else:
            self.widgets.get_object('back_button').set_sensitive(True)
        
        if self.index == len(self.images) - 1:
            self.widgets.get_object('forward_button').set_sensitive(False)
        else:
            self.widgets.get_object('forward_button').set_sensitive(True)
    
    def show_status_message(self, message, timeout=10):
        '''If a file cannot be opened this method is run to display an error
        message to the user.'''
        
        self.widgets.get_object('progressbar').hide()
        self.widgets.get_object('status_label').set_markup(message)
        self.widgets.get_object('status_box').show()
        
        def statusbar_hide():
            '''Hides the statusbar and then returns False to remove the glib
            timeout.'''
            
            self.widgets.get_object('status_box').hide()
            return False
        
        glib.timeout_add_seconds(timeout, statusbar_hide)
    
    def toggle_fullscreen(self, button):
        '''A callback connected to the fullscreen button's clicked signal.
        Changes the fullscreen property of the window depending on thes state of
        the button.'''
        
        if button.get_active():
            self.fullscreen()
        else:
            self.unfullscreen()
    
    def toggle_scale(self, button):
        '''A callback connected to the two scale button's clicked signals. It
        sets the window's scale property depending on which button is active.
        The scale property affects the way that images are loaded.'''
        
        old_scale = self.scale
        
        if button.get_active():
            if button is self.widgets.get_object('normal_button'):
                self.scale = DEFAULT_SIZE
            else:
                self.scale = FIT_BY_WIDTH
            
            if self.scale != old_scale:
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.lock.acquire()
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                    self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                    
                    self.lock.release()
                
                self.worker = threading.Thread(target=worker)
                self.worker.start()
    
    def unfocus(self):
        '''Focus the forward button so that spacebar presses don't activate any
        other widget.'''
        
        self.widgets.get_object('forward_button').grab_focus()
    
    def window_resized(self, window, allocation):
        '''A callback connected to the window's frame-event signal. It detects
        whether the window has been resized and if it has, resizes the image
        displayed to still properly fit the window.'''
        
        if (self.width != allocation.width or self.height != allocation.height):
            self.width = allocation.width
            self.height = allocation.height
            
            if self.open_file:
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.lock.acquire()
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                    self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                    
                    self.lock.release()
                
                self.worker = threading.Thread(target=worker)
                self.worker.start()
    

if __name__ == '__main__':
    ui = find_ui_definition()
    
    if not ui:
        sys.exit('A required file, colorwalk.ui, is missing. Unable to continue.')
    
    gtk.gdk.threads_init()
    
    if len(sys.argv) > 1:
        Window(ui, file=sys.argv[1])
    
    else:
        Window(ui)
    
    gtk.main()

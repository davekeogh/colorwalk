#!/usr/bin/env python

import sys, os, subprocess, threading, tempfile, shutil, time, gc, ConfigParser

import glib, gobject, gtk


IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.gif', '.png', '.bmp']
DEFAULT_SIZE = 123
FIT_BY_WIDTH = 456

LICENSE = '''This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.'''


def choose_file(path=None):
    '''Creates a gtk.FileChooser and returns the value when the dialog is 
    destroyed.'''
    
    dialog = gtk.FileChooserDialog(title='Open File', buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
            
    if path:
        dialog.set_current_folder(path)
            
    filter = gtk.FileFilter()
    filter.set_name('All supported files')
    filter.add_pattern('*.cbz')
    filter.add_pattern('*.cbr')
    filter.add_pattern('*.zip')
    filter.add_pattern('*.rar')
    dialog.add_filter(filter)
    filter = gtk.FileFilter()
    filter.set_name('All files')
    filter.add_pattern('*')
    dialog.add_filter(filter)
    
    if dialog.run() == gtk.RESPONSE_ACCEPT:
        file = dialog.get_filename()
    
    else:
        file = None
    
    dialog.destroy()
    
    return file 


def find_ui_definition():
    '''Tries to find the XML GtkBuilder file in all the usual places. The first
    place to be checked is the current working directory. If it's found we
    assume that we're debugging. If the file can't be found this function
    returns None.'''
    
    paths = os.environ['XDG_DATA_DIRS'].split(':')
    return_value = None
    
    # This is mostly so that debugging isn't a pain in the ass.
    local = os.path.join(os.getcwd(), 'colorwalk.ui')
    
    if os.path.exists(local):
        return_value = local
    
    if not return_value:
        for path in paths:
            full_path = os.path.join(path, 'colorwalk/colorwalk.ui')
            
            if os.path.exists(full_path):
                return_value = full_path
                break
    
    return return_value


def new_pixbuf(path, mode, width=-1, height=-1):
    '''Returns a gtk.gdk.Pixbuf object at the appropriate size.'''
    
    if mode == DEFAULT_SIZE:
        return gtk.gdk.pixbuf_new_from_file(path)
    elif mode == FIT_BY_WIDTH:
        temp = gtk.gdk.pixbuf_new_from_file(path)
        
        if temp.get_width() > width:
            del temp
            return gtk.gdk.pixbuf_new_from_file_at_size(path, width, -1)
        else:
            return temp
    
    # gtk.gdk.Pixbufs don't seem to be collected properly. I'm not sure if this
    # is the best spot to call the garbage collecter though.
    gc.collect()


def open_email(dialog, link, user_data):
    '''Attempts to open the default email program to send an email.'''
    
    subprocess.call(['xdg-open', 'mailto:%s' % link])


def open_url(dialog, link, user_data):
    '''Opens a url in the default web browser.'''
    
    subprocess.call(['xdg-open', link])


class AboutDialog(gtk.AboutDialog):
    
    def __init__(self):
        '''A custom about dialog window.'''
        
        # This is as good a spot as any to set these hooks.
        gtk.about_dialog_set_email_hook(open_email, None)
        gtk.about_dialog_set_url_hook(open_url, None)
        
        # we don't use gtk.LinkButton, but gtk.AboutDialog does;
        # in gtk 2.16.0 without this, the about uri opens doubly:
        gtk.link_button_set_uri_hook(lambda *args:None)

        gtk.AboutDialog.__init__(self)
        
        self.set_logo_icon_name('image')
        self.set_name('Color Walk')
        self.set_version('0.1.0')
        self.set_comments('A really simple comic book reading application')
        self.set_copyright('Copyright (c) 2009 David Keogh')
        self.set_authors(['David Keogh <davekeogh@shaw.ca>'])
        self.set_license(LICENSE)
        self.set_wrap_license(True)
        self.set_website('http://members.shaw.ca/davekeogh/')


class Preferences(ConfigParser.SafeConfigParser):
    
    config_file = os.path.expanduser('~/.config/colorwalk/config')
    
    def __init__(self):
        '''Represents a configuration file at ~/.config/colorwalk/config. 
        Creates one with the default values if it does not exist.'''
        
        ConfigParser.SafeConfigParser.__init__(self)
        
        if not os.path.exists(os.path.split(self.config_file)[0]):
            os.mkdir(os.path.split(self.config_file)[0])
        
        if os.path.exists(self.config_file):
            self.read(self.config_file)
        
        else:
            # Set some reasonable default values
            self.add_section('Window')
            self.set('Window', 'width', str(800))
            self.set('Window', 'height', str(800))
            self.set('Window', 'fullscreen', str(False))
            
            self.add_section('Image')
            self.set('Image', 'scale', str(456)) # FIT_BY_WIDTH
    
    def save(self):
        with open(self.config_file, 'w') as f:
            self.write(f)


class Window(gtk.Window):
    
    widgets = None
    worker = None
    lock = None
    preferences = Preferences()
    
    current_pixbuf = None
    prev_pixbuf = None
    next_pixbuf = None
    
    open_file = None
    index = 0
    images = []
    temp_dir = None
    browse_dir = None
    
    scale = FIT_BY_WIDTH
    width = 800
    height = 800
    
    def __init__(self, ui, file=None):
        '''The Colorwalk main window. Arguments: ui is the file path of a XML 
        user interface file, and the optional argument, file, is the path to a
        file to open.'''
        
        gtk.Window.__init__(self)
        
        # Load the widgets from the XML file:
        self.widgets = gtk.Builder()
        self.widgets.add_from_file(ui)
        
        # Window events:
        self.connect('delete-event', self.quit)
        self.connect('configure-event', self.window_resized)
        self.connect('key-press-event', self.key_pressed)
        
        # Tool button events:
        self.widgets.get_object('open_button').connect('clicked', self.open)
        self.widgets.get_object('forward_button').connect('clicked', self.go_forward)
        self.widgets.get_object('fullscreen_button').connect('toggled', self.toggle_fullscreen)
        self.widgets.get_object('back_button').connect('clicked', self.go_back)
        self.widgets.get_object('normal_button').connect('toggled', self.toggle_scale)
        self.widgets.get_object('fit_button').connect('toggled', self.toggle_scale)
        self.widgets.get_object('about_button').connect('clicked', self.about)
        
        # Entry events:
        self.widgets.get_object('entry').connect('insert-text', self.entry_contents_changed)
        self.widgets.get_object('entry').connect('activate', self.entry_activated)
        
        # Setup the accelerators:
        accel_group = gtk.AccelGroup()
        self.add_accel_group(accel_group)
        
        # Key values = backspace, page up:
        self.widgets.get_object('back_button').add_accelerator('clicked', accel_group, 65288, 0, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('back_button').add_accelerator('clicked', accel_group, 65365, 0, (gtk.ACCEL_LOCKED))
        
        # Key values = spacebar, page down:
        self.widgets.get_object('forward_button').add_accelerator('clicked', accel_group, 32, 0, (gtk.ACCEL_LOCKED))
        self.widgets.get_object('forward_button').add_accelerator('clicked', accel_group, 65366, 0, (gtk.ACCEL_LOCKED))
        
        # Resize window according to preferences:
        self.resize(self.preferences.getint('Window', 'width'),
                    self.preferences.getint('Window', 'height'))
        self.scale = self.preferences.getint('Image', 'scale')
        
        if self.preferences.getboolean('Window', 'fullscreen'):
            self.widgets.get_object('fullscreen_button').set_active(True)
        
        # Display the widgets:
        self.set_icon_name('image')
        self.set_title('Color Walk')
        self.add(self.widgets.get_object('vbox'))
        self.set_toolbar_button_sensitivity(False)
        self.show()
        
        # Open a file passed on the command line:
        if file:
            self.open(self.widgets.get_object('open_button'), file=file)
    
    def about(self, button):
        '''Shows the about dialog.'''
        
        dialog = AboutDialog()
        if dialog.run():
            dialog.destroy()
    
    def close_file(self):
        '''Reset all relevant variables and delete the temporary directory.'''
        
        self.current_pixbuf = None
        self.next_pixbuf = None
        self.prev_pixbuf = None
        
        self.index = 0
        self.images = []
        self.open_file = None
        
        if self.temp_dir:
            shutil.rmtree(self.temp_dir)
    
    def entry_activated(self, entry):
        '''A callback connected to the entry's activate signal. First the text
        is verified and then, if it's numerical, the correct page is opened.'''
        
        def fail():
            '''This is run when what's entered is invalid. It resets the entry
            widget and removes the focus from the entry.'''
            
            entry.set_text(str(self.index + 1))
            self.unfocus()
        
        try:
            index = int(entry.get_text()) - 1
            
            if index >= 0 and index < len(self.images):
                self.index = index
                
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.reset_scrollbars()
                    self.set_widget_state()
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    try:
                        self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                    except IndexError:
                        self.next_pixbuf = None
                    
                    try:
                        self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                    except IndexError:
                        self.prev_pixbuf = None
                
                self.worker = threading.Thread(target=worker)
                self.worker.start()
            else:
                # The number falls outside the actual number of images.
                fail()
        except ValueError:
            # Non-numerical value.
            fail()
    
    def entry_contents_changed(self, entry, text, text_length, pointer):
        '''Prevent any non numerical characters from being entered into the
        entry.'''
        
        try:
            int(text)
        except ValueError:
            entry.stop_emission('insert-text')
    
    def fail(self, message):
        '''If a file cannot be opened this method is run to display an error
        message to the user.'''
        
        self.widgets.get_object('progressbar').hide()
        self.widgets.get_object('status_label').set_markup(message)
        self.widgets.get_object('hbox2').show()
        
        def statusbar_hide():
            '''Hides the statusbar and then returns False to remove the glib
            timeout.'''
            
            self.widgets.get_object('hbox2').hide()
            return False
        
        glib.timeout_add_seconds(10, statusbar_hide)
    
    def get_available_space(self):
        '''Returns the amount of space that the image can occupy in pixels.'''
        
        # TODO: Find a way to get the scrollbar's actual width.
        scrollbar = 20
        
        height = self.height - self.widgets.get_object('toolbar').size_request()[0]
        width = self.width - scrollbar
        
        return (width, height)
    
    def go_back(self, button):
        '''A callback connected to the back button's clicked signal. Displays
        the previous page.'''
        
        if self.index >= 0:
            if self.prev_pixbuf:
                self.index -= 1
                
                self.next_pixbuf = self.current_pixbuf
                self.current_pixbuf = self.prev_pixbuf
                self.prev_pixbuf = None
                
                self.reset_scrollbars()
                self.set_widget_state()
                
                self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                
                self.worker = threading.Thread(target=worker)
                self.worker.start()
    
    def go_forward(self, button):
        '''A callback connected to the forward button's clicked signal. Displays
        the next page.'''
        
        if self.index < len(self.images):
            if self.next_pixbuf:
                self.index += 1
                
                self.prev_pixbuf = self.current_pixbuf
                self.current_pixbuf = self.next_pixbuf
                self.next_pixbuf = None
                
                self.reset_scrollbars()
                self.set_widget_state()
                
                self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                
                if self.index != len(self.images) - 1:
                    def worker():
                        '''Runs in the background to avoid blocking the UI.
                        Opens the required images.'''
                        
                        self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                    
                    self.worker = threading.Thread(target=worker)
                    self.worker.start()
    
    def go_to_index(self, index):
        '''Displays the page refered to by the value of index. This is only used
        internally with safe values for index, so we don't need to check the
        value of index here.'''
        
        self.index = index
        
        def worker():
            '''Runs in the background to avoid blocking the UI. Opens the
            required images.'''
            
            self.reset_scrollbars()
            self.set_widget_state()
            
            self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
            self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
            
            self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
            self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
        
        self.worker = threading.Thread(target=worker)
        self.worker.start()
    
    def key_pressed(self, widget, event):
        '''A callback onnected to the window's key-pressed-event. Does something 
        depending on the key.'''
        
        if event.keyval == 65480: # F11
            self.widgets.get_object('fullscreen_button').set_active(not self.widgets.get_object('fullscreen_button').get_active())
        
        if self.open_file:
            if event.keyval == 65360: # Home
                self.go_to_index(widget, 0)
            
            elif event.keyval == 65367: # End
                self.go_to_index(widget, len(self.images) - 1)
    
    def open(self, button, file=None):
        '''A callback connected to the open button's clicked signal. Can also be
        called with a file as an argument to open files passed as command line
        arguments. If the file is valid the archive is opened. Otheriwse, the 
        fail() method is called and an error message is displayed.'''
        
        button.set_sensitive(False)
        
        if file:
            file = os.path.abspath(file)
            self.browse_dir = os.path.split(file)[0]
            
            if not os.path.exists(file):
                file = None
        
        else:
            file = choose_file(self.browse_dir)
        
            try:
                self.browse_dir = os.path.split(file)[0]
                
                if self.open_file:
                    self.close_file()
            
            except AttributeError:
                pass
        
        if file:
            ext = os.path.splitext(file)[1]
            
            if ext == '.zip' or ext == '.cbz':
                self.temp_dir = tempfile.mkdtemp(prefix='colorwalk-%s-' % os.environ['USER'])
                command = 'unzip -j \"%s\" -d \"%s\"' % (file, self.temp_dir)
                
            elif ext == '.rar' or ext == '.cbr':
                self.temp_dir = tempfile.mkdtemp(prefix='colorwalk-%s-' % os.environ['USER'])
                command = 'unrar e \"%s\" \"%s\"' % (file, self.temp_dir)
                
            else:
                command = None
        
        else:
            command = None
        
        if command:
            def worker():
                '''Runs in the background to avoid blocking the UI. Opens the
                required images.'''
                
                self.widgets.get_object('status_label').set_markup('Opening <i>%s</i> ...' % os.path.split(file)[1])
                self.widgets.get_object('hbox2').show()
                
                p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                
                while p.poll() == None:
                    # Wait until the archive is done extracting before we do
                    # anything else.
                    self.widgets.get_object('progressbar').pulse()
                    time.sleep(0.1)
                
                for f in os.listdir(self.temp_dir):
                    # Only add files with a valid extension to the list of
                    # images.
                    if os.path.splitext(f)[1].lower() in IMAGE_EXTENSIONS:
                        self.images.append(f)
                
                if not len(self.images):
                    button.set_sensitive(True)
                    self.fail('<i>%s</i> cannot be opened because it does not contain any images.' % os.path.split(file)[1])
                
                else:
                    self.images.sort(key=str.lower)
                    self.open_file = file
                    
                    self.reset_scrollbars()
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[0]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    button.set_sensitive(True)
                    self.set_widget_state()
                    self.set_toolbar_button_sensitivity(True)
                    self.widgets.get_object('hbox2').hide()
                    
                    self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[1]), self.scale, *self.get_available_space())
            
            self.worker = threading.Thread(target=worker)
            
            self.worker.start()
        
        elif file and not command:
            button.set_sensitive(True)
            self.fail('<i>%s</i> cannot be opened because it is not a valid archive file.' % os.path.split(file)[1])
        
        else:
            button.set_sensitive(True)
    
    def quit(self, window, event):
        '''A callback connected to the window's delete-event signal. It deletes
        the temporary directory, if it exists, saves the preferences, and
        destroys the window.'''
        
        if self.temp_dir:
            shutil.rmtree(self.temp_dir)
        
        if self.widgets.get_object('fullscreen_button').get_active():
            self.preferences.set('Window', 'fullscreen', str(True))
        else:
            self.preferences.set('Window', 'fullscreen', str(False))
        self.preferences.set('Window', 'width', str(self.width))
        self.preferences.set('Window', 'height', str(self.height))
        self.preferences.set('Image', 'scale', str(self.scale))
        self.preferences.save()
        
        gtk.main_quit()
        sys.exit(0)
    
    def reset_scrollbars(self):
        '''This method moves the scrollbars back to their default positions.'''
        
        viewport = self.widgets.get_object('scrolledwindow')
        hadj = viewport.get_hadjustment()
        vadj = viewport.get_vadjustment()
        vadj.set_value(vadj.lower)
        hadj.set_value(hadj.lower)
        viewport.set_hadjustment(hadj)
        viewport.set_vadjustment(vadj)
    
    def set_toolbar_button_sensitivity(self, bool):
        '''Calls the toolbar buttons set_sensitive() methods with the value of
        bool.'''
        
        self.widgets.get_object('back_button').set_sensitive(bool)
        self.widgets.get_object('forward_button').set_sensitive(bool)
        self.widgets.get_object('normal_button').set_sensitive(bool)
        self.widgets.get_object('fit_button').set_sensitive(bool)
        self.widgets.get_object('entry').set_sensitive(bool)
        self.widgets.get_object('label').set_sensitive(bool)
    
    def set_widget_state(self):
        '''Updates properites of any widget that may change depending on whether
        an image is being displayed.'''
        
        self.set_title('%s - %s' % (os.path.split(self.open_file)[1], self.images[self.index]))
        self.widgets.get_object('entry').set_text(str(self.index + 1))
        self.widgets.get_object('label').set_text('of %d' % len(self.images))
        
        self.unfocus()
        
        if self.index == 0:
            self.widgets.get_object('back_button').set_sensitive(False)
        else:
            self.widgets.get_object('back_button').set_sensitive(True)
        
        if self.index == len(self.images) - 1:
            self.widgets.get_object('forward_button').set_sensitive(False)
        else:
            self.widgets.get_object('forward_button').set_sensitive(True)
    
    def toggle_fullscreen(self, button):
        '''A callback connected to the fullscreen button's clicked signal.
        Changes the fullscreen property of the window depending on thes state of
        the button.'''
        
        if button.get_active():
            self.fullscreen()
        else:
            self.unfullscreen()
    
    def toggle_scale(self, button):
        '''A callback connected to the two scale button's clicked signals. It
        sets the window's scale property depending on which button is active.
        The scale property affects the way that images are loaded.'''
        
        if button.get_active():
            if button is self.widgets.get_object('normal_button'):
                self.scale = DEFAULT_SIZE
            else:
                self.scale = FIT_BY_WIDTH
    
    def unfocus(self):
        '''Focus the forward button so that spacebar presses don't activate any
        other widget.'''
        
        self.widgets.get_object('forward_button').grab_focus()
    
    def window_resized(self, window, allocation):
        '''A callback connected to the window's frame-event signal. It detects
        whether the window has been resized and if it has, resizes the image
        displayed to still properly fit the window.'''
        
        if (self.width != allocation.width or self.height != allocation.height):
            self.width = allocation.width
            self.height = allocation.height
            
            if self.open_file:
                def worker():
                    '''Runs in the background to avoid blocking the UI. Opens
                    the required images.'''
                    
                    self.current_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index]), self.scale, *self.get_available_space())
                    self.widgets.get_object('image').set_from_pixbuf(self.current_pixbuf)
                    
                    self.next_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index + 1]), self.scale, *self.get_available_space())
                    self.prev_pixbuf = new_pixbuf(os.path.join(self.temp_dir, self.images[self.index - 1]), self.scale, *self.get_available_space())
                    
                self.worker = threading.Thread(target=worker)
                self.worker.start()
    

if __name__ == '__main__':
    ui = find_ui_definition()
    
    if not ui:
        sys.exit('A required file, colorwalk.ui, is missing. Unable to continue.')
    
    gtk.gdk.threads_init()
    
    if len(sys.argv) > 1:
        Window(ui, file=sys.argv[1])
    
    else:
        Window(ui)
    
    gtk.main()
